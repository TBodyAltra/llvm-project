; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc -mtriple=tinygpu -verify-machineinstrs < %s | FileCheck -check-prefix=ASM %s

define void @matadd(ptr addrspace(1) %A, ptr addrspace(1) %B, ptr addrspace(1) %C) {
; ASM-LABEL: matadd:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    MUL R3, blockIdx, blockDim
; ASM-NEXT:    ADD R3, R3, threadIdx
; ASM-NEXT:    ADD R1, R1, R3
; ASM-NEXT:    LDR R1, R1
; ASM-NEXT:    ADD R0, R0, R3
; ASM-NEXT:    LDR R0, R0
; ASM-NEXT:    ADD R0, R0, R1
; ASM-NEXT:    ADD R1, R2, R3
; ASM-NEXT:    STR R0, R1
; ASM-NEXT:    RET
entry:
  ; Get blockIdx, blockDim, and threadIdx using built-in functions
  %blockIdx = call i8 @llvm.tinygpu.workgroup.id.x()
  %blockDim = call i8 @llvm.tinygpu.workgroup.size.x()
  %threadIdx = call i8 @llvm.tinygpu.workitem.id.x()

  ; i = blockIdx * blockDim + threadIdx
  %tmp1 = mul i8 %blockIdx, %blockDim
  %i = add i8 %tmp1, %threadIdx

  ; addr(A[i]) = baseA + i
  %ptrA = getelementptr i8, ptr addrspace(1) %A, i8 %i
  ; load A[i] from global memory
  %valA = load i8, ptr addrspace(1) %ptrA

  ; addr(B[i]) = baseB + i
  %ptrB = getelementptr i8, ptr addrspace(1) %B, i8 %i
  ; load B[i] from global memory
  %valB = load i8, ptr addrspace(1) %ptrB

  ; C[i] = A[i] + B[i]
  %sum = add i8 %valA, %valB

  ; addr(C[i]) = baseC + i
  %ptrC = getelementptr i8, ptr addrspace(1) %C, i8 %i
  ; store C[i] in global memory
  store i8 %sum, ptr addrspace(1) %ptrC

  ret void
}

declare i8 @llvm.tinygpu.workgroup.id.x()
declare i8 @llvm.tinygpu.workgroup.size.x()
declare i8 @llvm.tinygpu.workitem.id.x()
